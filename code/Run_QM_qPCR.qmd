 ---
title: "Joint QM-qPCR Model of Hake Survey Samples"
format: 
  html: 
    self-contained: true
    toc: true
  pdf: 
    toc: true
    include-in-header:
      - text: |
          \usepackage{subfig}
          \usepackage{pdflscape}
          \newcommand{\blandscape}{\begin{landscape}}
          \newcommand{\elandscape}{\end{landscape}}
editor: visual
---

```{r setup}
library(tidyverse)
library(rstan)
library(here)

```


# Introduction

We implement and fit a Stan model that jointly models qPCR and metabarcoding data for hake survey samples. The goal is to make quantitative estimates of real eDNA concentration for species for which we have MiFish metabarcoding data, but DO NOT have qPCR data. We use qPCR data from one, common reference species (Pacific hake) to expand metabarcoding read counts into quantitative eDNA concentration estimates.

# Import Data

The first script loads the metabarcoding, qPCR, and mock community data. The second script loads functions that are useful for working with the data and setting up the Stan model.

```{r}
source(here('code','1_load_data.R'))

source(here("code/qm_data_prep_functions.R"))
```

## Format for Stan

We can prepare the data we just loaded to be input into our Stan model, using some of the functions in the previous script.

```{r}
#qPCR
formatted_qPCR_data <- format_qPCR_data(qPCR_unknowns=qPCR_unk,
                                   qPCR_standards=qPCR_std,
                                   tube_dat = tube_dat,
                                   unk_covariates=c("wash_idx","station_depth_idx"),cov_type = c("continuous","factor"),
                                   unk_offset =c("dilution","volume_offset"))

stan_qPCR_data <- prepare_stan_data_qPCR(formatted_qPCR_data) %>% 
                    # Add Random effect for station
                    c(.,
                      list(X_bio_rep_tube =X_bio_rep_tube,
                           X_bio_rep_obs =X_bio_rep_obs,
                           X_station_depth_tube=X_station_depth_tube,
                           N_bio_rep_RE = N_bio_rep_RE,
                           N_bio_rep_param = N_bio_rep_param,
                           bio_rep_idx =bio_rep_idx,
                           N_bio_rep_idx = N_bio_rep_idx))

# metabarcoding
formatted_metabarcoding_data <- format_metabarcoding_data(input_metabarcoding_data=mfu, 
                                                          input_mock_comm_data=mock,
                                                     Level_1_treatment_envir <- "Sample",
                                                     Level_2_treatment_envir <- "tech",
                                                     Level_3_treatment_envir <- NA,
                                                     Level_1_treatment_mock <- "Sample",
                                                     Level_2_treatment_mock <- "Rep",
                                                     Level_3_treatment_mock <- NA)

# linking with qPCR is now done within this function.
stan_metabarcoding_data <-  makeDesign(obs= formatted_metabarcoding_data,
                                       qPCR_tube_obs = formatted_qPCR_data$tube_dat,
                                  N_pcr_cycles = 43, Nlevels_mock = 2, Nlevels_samp = 2)

log_D_link_sp_init_mean = 2
link_species = "Merluccius productus"
log_D_inits <- makeQM_inits(sample_data =stan_metabarcoding_data$sample_data, 
                         log_D_link_sp_init_mean = log_D_link_sp_init_mean,
                         sp_list = formatted_metabarcoding_data$sp_list,
                         qPCR_ref_sp = link_species )



# get the index of the right species
qpcr_mb_link_sp_idx <- formatted_metabarcoding_data$sp_list$species_idx[formatted_metabarcoding_data$sp_list$species == link_species]

# join the three lists
stan_data_joint <- c(stan_qPCR_data,
                     stan_metabarcoding_data,
                     list(qpcr_mb_link_sp_idx=qpcr_mb_link_sp_idx))
# Check to make sure the order is correct for two of the design matrices that 
# map to observation and the tubes.  Very important.
identical(colnames(X_bio_rep_tube),colnames(X_bio_rep_obs))
identical(colnames(X_station_depth_tube),colnames(stan_data_joint$X_station_depth_obs))

```

Now the data should be ready for Stan. We compile the Stan model itself:

## Load Stan model

```{r}
m <- here('code','qm_qpcr_joint.stan')
m_dm <- here('code','qm_qpcr_joint-DM.stan') # Dirichlet multinomial

m_dm_mock <- here('code','qm_mocks-DM.stan') # Dirichlet multinomial for mocks
m_dm_test <- here('code','deprecated','qm_qpcr_joint-DM_alpha-fix_test.stan')

#IF YOU NEED TO ERROR CHECK, COPY AND PASTE "mc" INTO A NEW SCRIPT TO FIND THE RIGHT LINE NUMBERS
# mc <- cat(stan_model(m)@model_code)
```

# Run

Run Stan

```{r}
# n.chains <- 3
# n.warm <- 500
# n.samps <- 3000
# jointMod = stan(file = m ,
#                 data = stan_data_joint,
#                 verbose = FALSE,
#                 chains = n.chains,
#                 thin = 1,
#                 warmup = n.warm,
#                 iter = n.warm+n.samps,
#                 control = list(adapt_init_buffer = 75,
#                                   max_treedepth=12,
#                                   stepsize=0.01,
#                                   adapt_delta=0.8,
#                                   metric="diag_e"),
#                 init = stan_init_f1(n.chains,N_obs_mb = stan_data_joint$N_obs_mb_samp,
#                                     N_species = stan_data_joint$N_species,
#                                     Nplates=stan_data_joint$Nplates,
#                                     N_station_depth=stan_data_joint$N_station_depth,
#                                     log_D_link_sp_init_mean=log_D_inits$log_D_link_sp_init_mean),
#                                     # log_D_raw_inits=log_D_inits$log_D_raw_inits),
#                                     # log_D_log_D_inits$log_D_inits,
#                 refresh = 10,
#                 boost_lib = NULL
#                 # sample_file="tmpU.csv"
#                 )
```

## Dirichlet multinomial

First, run the model for the mock communities

```{r}
# Mocks only
n.chains <- 3
n.warm <- 500
n.samps <- 10000

mocksMod = stan(file = m_dm_mock ,

                data = stan_data_joint,
                verbose = FALSE,
                chains = n.chains,
                thin = 1,
                warmup = n.warm,
                iter = n.warm+n.samps,
                control = list(adapt_init_buffer = 75,
                                  max_treedepth=12,
                                  stepsize=0.01,
                                  adapt_delta=0.8,
                                  metric="diag_e"),
                init = stan_init_f1(n.chains,N_obs_mb = stan_data_joint$N_obs_mb_samp,
                                    N_species = stan_data_joint$N_species,
                                    Nplates=stan_data_joint$Nplates,
                                    N_station_depth=stan_data_joint$N_station_depth
                                    # log_D_link_sp_init_mean=log_D_inits$log_D_link_sp_init_mean,
                                    # log_D_raw_inits=log_D_inits$log_D_raw_inits,
                                    # log_D_inits = log_D_inits$log_D_inits
                                    ),
                #refresh = 100,
                boost_lib = NULL
                # sample_file="tmpU.csv"
                )

#summary(mocksMod)
A <- summary(mocksMod,pars="alpha")
B <- summary(mocksMod,pars="dm_alpha0_mock")

# rstan::traceplot(mocksMod,pars=c("alpha"))
# rstan::traceplot(mocksMod,pars=c("log_dm_alpha0_mock"))

alpha_fix <- A$summary %>% as.data.frame() %>% dplyr::select(mean) 
dm_alpha0_mock <- B$summary %>% as.data.frame() %>% dplyr::select(mean)

stan_data_joint <- c(stan_data_joint,
                     list(alpha_fix=(alpha_fix$mean),
                                                dm_alpha0_mock=dm_alpha0_mock$mean))
```

Then, run the joint model with fixed alphas drawn from the model above.

```{r}
n.chains <- 3
n.warm <- 400
n.samps <-100
tictoc::tic("Running DM Joint Model:")
# jointMod_dm = stan(file = "qm_qpcr_joint-DM_alpha-fix.stan",
jointMod_dm = stan(file = m_dm_test,
                data = stan_data_joint,
                verbose = FALSE,
                chains = n.chains,
                thin = 1,
                warmup = n.warm,
                iter = n.warm+n.samps,
                control = list(adapt_init_buffer = 80,
                                max_treedepth=11,
                                stepsize=0.05,
                                adapt_delta=0.80,
                                metric="diag_e"),
                init = stan_init_f1(n.chains,N_obs_mb = stan_data_joint$N_obs_mb_samp,
                                    N_species = stan_data_joint$N_species,
                                    Nplates=stan_data_joint$Nplates,
                                    N_station_depth=stan_data_joint$N_station_depth
                                    # log_D_link_sp_init_mean=log_D_inits$log_D_link_sp_init_mean,
                                    # log_D_raw_inits=log_D_inits$log_D_raw_inits,
                                    # log_D_inits=log_D_inits$log_D_inits
                                    ),
                refresh = 10,
                boost_lib = NULL,
                sample_file="tmpX.csv"
                )
tictoc::toc()
```


```{r}
# save (big file!)
write_rds(jointMod,here('code','fit1.rds'))
write_rds(jointMod_dm,here('code','fit_dm.rds'))

# if reading
jointMod <- read_rds(here('code','fit1.rds'))
jointMod_dm <- read_rds(here('code','fit_dm.rds'))
```

# Diagnostics - Observations and Predictions

```{r}
# Code for these diagnostic plots
source(here('code','diagnostics.R'))
fit_summ <- get_param_ests(jointMod_dm)
```

## qPCR

```{r}
plot_obs_pred_qPCR(fit_summ,stan_data_joint)
```

Look a little closer at the outlier field samples

```{r,fig.height=3,fig.width=4}
qpcr_out <- plot_obs_pred_qPCR(fit_summ,stan_data_joint,return_what = 'data') %>% pluck('qPCR_unk')
qpcr_out <- qpcr_out %>% 
  filter(z==1) %>% 
  mutate(Ctdiff=Ct_fit-Ct)
qpcr_out %>% 
  ggplot(aes(Ctdiff))+geom_histogram()+labs(x="Predicted - Observed")

# upper 5% most divergent
qpcr_outliers <- qpcr_out %>% 
  mutate(absdiff=abs(Ctdiff)) %>% 
  mutate(percent_rank(absdiff)>0.95)
qpcr_outliers %>% 
  ggplot(aes(absdiff))+geom_histogram()+labs(x="Absolute Difference")

# there's an obvious break between a Ct difference of ~8 and ~13. Maybe we should remove all the ones in that upper bin?
qpcr_outliers2 <- qpcr_outliers %>% filter(absdiff>9)
```


## QM

```{r,fig.height=3,fig.width=6}
# alphas
plot_alphas(fit_summ)
```

```{r,fig.width=8,fig.height=7}
plot_obs_pred_qm_no_mocks(fit_summ,stan_data_joint)
```

```{r}
plot_est_reads(fit_summ)
```

# Save Predictions

Save the predictions of log copies for use in downstream spatial modeling and plotting

```{r}
# log_D from the model fit
reads_fitted <- fit_summ %>% 
  filter(grepl('log_D',variable),
         !grepl('log_D_raw',variable),
         !grepl('log_D_mu',variable),
         !grepl('log_D_sp',variable),
         !grepl('log_D_station_depth',variable),
         !grepl('log_D_sigma',variable)) %>%
  # extract a replicate number from the variable names using regex
  mutate(rep=str_extract(variable,"(?<=\\[)\\d+") %>% as.integer)%>% 
  # extract a species number from the variable names using regex
  mutate(taxa=str_extract(variable,"(?<=\\,)\\d+") %>% as.integer) %>% 
  # add a species name
  mutate(species=unique(mfu$species)[taxa])

## Match to input qpcr/mb link data, then to metadata mfu_META
## THIS IS HOW THE MATCHING IS SET UP IN DATA PREP- TRY TO AVOID MISTAKES BY DOING THE SAME THING HERE
## IF 1_load_data has been run, needed objects should all be in the environment

mb_link_1 <- mfu %>% 
    mutate(mb_link=match(Sample,unique(Sample))) %>% 
    distinct(Sample,.keep_all = T)
  
mb_link_2 <- tube_dat %>% 
    distinct(tubeID,tube_idx,station_depth_idx,station_idx) %>%
    #distinct(plate_idx,qpcr_sample_idx,.keep_all = T) %>%
    left_join(mb_link_1,by=join_by(tubeID==Sample)) %>% 
    filter(!is.na(mb_link)) %>%
    arrange(tube_idx) 
# with spatial info
mb_join_key <- mb_link_2 %>% left_join(mfu_META,by=join_by(tubeID==sample)) %>% 
  dplyr::select(tubeID,tube_idx,lat,lon,depth,depth_cat,wash_idx) %>% 
  mutate(rep=row_number())

# join
reads_fitted <- reads_fitted %>% 
  left_join(mb_join_key,by=join_by(rep)) %>% 
  dplyr::select(-rep)

# write
write_rds(reads_fitted,here('code','log_D_fitted.rds'))
```


# Diagnostics- Sampler

```{r,fig.height=3,fig.width=4}
samps <- read_csv(here('code','tmpU.csv'),skip = 25,col_select = c(1:100))
sampslong <- samps %>% 
  mutate(samp=row_number()) %>% 
  dplyr::select(-(1:7)) %>% 
  pivot_longer(-samp,names_to = "param",values_to="value")

# function to plot the path of the sampler for a param or group of params
plot_trace <- function(samples,param_str){
  samples %>% 
    filter(grepl(param_str,param)) %>% 
    ggplot(aes(samp,value,group=param))+
    geom_line()+
    guides(group='none',col='none')+
    theme_minimal()+
    labs(title=param_str)
}

plot_trace(sampslong,"logit_val_samp")
plot_trace(sampslong,"logit_val_mock")
# plot_trace(sampslong,"eta_mock")
plot_trace(sampslong,"alpha.2")
plot_trace(sampslong,'mean_hake')
plot_trace(sampslong,"log_D_sigma")
plot_trace(sampslong,"dm_alpha0_mock")
# plot_trace(sampslong,"bio_rep_RE")
```

```{r}
# Dirichlet alpha vs. likelihood
testdm <- sampslong %>% 
    filter(grepl("log_dm_alpha0_mock",param)) %>% 
  rename(log_dm_alpha0=value) %>% 
  select(-param)
testlp <- samps %>% 
  mutate(samp=row_number()) %>% 
  dplyr::select(samp,"lp__") %>% 
  pivot_longer(-samp,names_to = "param",values_to="value") %>% 
  left_join(testdm) %>% 
  mutate(across(c(3,4),as.numeric))
testlp %>% 
  ggplot(aes(log_dm_alpha0,value))+geom_point()
```


```{r,fig.height=4}
# inits
inits_samps <- rstan::get_inits(jointMod_dm) %>% 
  set_names(1:n.chains) %>% pluck(1)

# sampler params
diagnose_sampler <- rstan::get_sampler_params(jointMod_dm) %>% 
  set_names(1:n.chains) %>% 
   map_df(as_tibble,.id = 'chain') %>% 
  group_by(chain) %>% 
  mutate(iteration = 1:length(chain)) %>% 
  mutate(warmup = iteration <= n.warm)

# divergences
diagnose_sampler %>% 
  group_by(warmup, chain) %>% 
  summarise(percent_divergent = mean(divergent__ >0)) %>% 
  ggplot() +
  geom_col(aes(chain, percent_divergent, fill = warmup), position = 'dodge', color = 'black') + 
  scale_y_continuous(labels = scales::percent, name = "% Divergent Runs")
# treedepth
maxtd <- jointMod_dm@stan_args[[1]]$control$max_treedepth
diagnose_sampler %>% 
  ggplot(aes(iteration, treedepth__, color = chain)) + 
  geom_line() + 
  # horizontal line at the value we set our max treedepth
  geom_hline(aes(yintercept = maxtd), color = 'blue')
```

```{r}
#n_eff and Rhat
fit_summ %>% 
  ggplot(aes(n_eff)) + 
  geom_histogram() + 
  geom_vline(aes(xintercept = 3000), color = 'red')
fit_summ %>%
  ggplot(aes(Rhat)) + 
  geom_histogram() + 
  geom_vline(aes(xintercept = 1.1), color = 'red')
```


```{r}
# try to compare a sample of mu to observed
# mu_samp_est <- stansamps %>% slice(nrow(stansamps)-5) %>% unlist()
# mu_samp_obs <- as.matrix(stan_data_joint$sample_data/rowSums(stan_data_joint$sample_data)) %>% c()
# mu_samp_check <- tibble(est=mu_samp_est,ob=c(mu_samp_obs))
# mu_samp_check %>% 
#   ggplot(aes(est,ob))+
#   geom_point()+
#   geom_abline(slope=1,intercept=0,linetype=2)+
#   labs(x="Estimated",y="Observed")
```


```{r}
shinystan::launch_shinystan(jointMod_dm)
```


```{r}
ests <- summary(jointMod,par="log_D")$summary
ests2 <- summary(jointMod,par="log_D_raw")$summary
```


