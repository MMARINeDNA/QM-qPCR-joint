 ---
title: "Joint QM-qPCR Model of Hake Survey Samples"
format: 
  html: 
    self-contained: true
    toc: true
  pdf: 
    toc: true
    include-in-header:
      - text: |
          \usepackage{subfig}
          \usepackage{pdflscape}
          \newcommand{\blandscape}{\begin{landscape}}
          \newcommand{\elandscape}{\end{landscape}}
editor: visual
---

```{r setup}
library(tidyverse)
library(rstan)
library(here)
```


# Introduction

We implement and fit a Stan model that jointly models qPCR and metabarcoding data for hake survey samples. The goal is to make quantitative estimates of real eDNA concentration for species for which we have MiFish metabarcoding data, but DO NOT have qPCR data. We use qPCR data from one, common reference species (Pacific hake) to expand metabarcoding read counts into quantitative eDNA concentration estimates.

# Import Data

The first script loads the metabarcoding, qPCR, and mock community data. The second script loads functions that are useful for working with the data and setting up the Stan model.

```{r}
source(here('code','1_load_data.R'))

source(here("code/qm_data_prep_functions.R"))
```

## Format for Stan

We can prepare the data we just loaded to be input into our Stan model, using some of the functions in the previous script.

```{r}
#qPCR
formatted_qPCR_data <- format_qPCR_data(qPCR_unknowns=qPCR_unk,
                                   qPCR_standards=qPCR_std,
                                   unk_covariates=c("wash_idx","station_depth_idx"),cov_type = c("continuous","factor"),
                                   unk_offset =c("dilution","volume_offset"))

stan_qPCR_data <- prepare_stan_data_qPCR(formatted_qPCR_data) %>% 
                    # Add Random effect for station
                    c(.,
                      list(X_bio_rep_tube =X_bio_rep_tube,
                           X_bio_rep_obs =X_bio_rep_obs,
                           X_station_depth_tube=X_station_depth_tube,
                           N_bio_rep_RE = N_bio_rep_RE,
                           N_bio_rep_param = N_bio_rep_param,
                           bio_rep_idx =bio_rep_idx,
                           N_bio_rep_idx = N_bio_rep_idx,
                           beta_std_curve_0_offset =36))


# metabarcoding
formatted_metabarcoding_data <- format_metabarcoding_data(mfu, mock,
                                                     Level_1_treatment_envir <- "Sample",
                                                     Level_2_treatment_envir <- "tech",
                                                     Level_3_treatment_envir <- NA,
                                                     Level_1_treatment_mock <- "Sample",
                                                     Level_2_treatment_mock <- "Rep",
                                                     Level_3_treatment_mock <- NA)



stan_metabarcoding_data <-  makeDesign(obs= formatted_metabarcoding_data,
                                       qPCR_obs = formatted_qPCR_data$qPCR_unk,
                                         N_pcr_cycles = 43, Nlevels_mock = 2, Nlevels_samp = 2,
                                       )


# linking data
qPCR_mb_link <- prepare_stan_qPCR_mb_join(input_metabarcoding_data=mfu,
                                          unk_formatted = formatted_qPCR_data$qPCR_unk,
                                          link_species = "Merluccius productus")

# join the three lists
stan_data_joint <- c(stan_qPCR_data,
                     stan_metabarcoding_data,
                     qPCR_mb_link)
# Check to make sure the order is correct for two of the design matrices that 
# map to observation and the tubes.  Very important.
    identical(colnames(X_bio_rep_tube),colnames(X_bio_rep_obs))
    identical(colnames(X_station_depth_tube),colnames(stan_data_joint$X_station_depth_obs))

```

Now the data should be ready for Stan. We compile the Stan model itself:

## Load Stan model

```{r}
m <- here('code','qm_qpcr_joint.stan')

#IF YOU NEED TO ERROR CHECK, COPY AND PASTE "mc" INTO A NEW SCRIPT TO FIND THE RIGHT LINE NUMBERS
# mc <- cat(stan_model(m)@model_code)
```

# Run

Run Stan

```{r}
n.chains <- 3
n.warm <- 200
n.samps <- 100
jointMod = stan(file = m ,
                data = stan_data_joint,
                verbose = FALSE,
                chains = n.chains,
                thin = 1,
                warmup = n.warm,
                iter = n.warm+n.samps,
                control = list(#adapt_init_buffer = 150,
                                  max_treedepth=10,
                                  stepsize=0.01,
                                  adapt_delta=0.8,
                                  metric="diag_e"),
                init = stan_init_f1(n.chains,N_obs_mb = stan_data_joint$N_obs_mb_samp,
                                    N_species = stan_data_joint$N_species,
                                    Nplates=stan_data_joint$Nplates,
                                    N_station_depth=stan_data_joint$N_station_depth),
                #refresh = 10,
                boost_lib = NULL,
                sample_file="tmpG.csv"
                )
```

```{r}
# inits
inits_samps <- rstan::get_inits(jointMod) %>% 
  set_names(1:n.chains) %>% pluck(1)

# sampler params
diagnose_sampler <- rstan::get_sampler_params(jointMod) %>% 
  set_names(1:n.chains) %>% 
   map_df(as_tibble,.id = 'chain') %>% 
  group_by(chain) %>% 
  mutate(iteration = 1:length(chain)) %>% 
  mutate(warmup = iteration <= n.warm)

# divergences
diagnose_sampler %>% 
  group_by(warmup, chain) %>% 
  summarise(percent_divergent = mean(divergent__ >0)) %>% 
  ggplot() +
  geom_col(aes(chain, percent_divergent, fill = warmup), position = 'dodge', color = 'black') + 
  scale_y_continuous(labels = scales::percent, name = "% Divergent Runs")
# treedepth
maxtd <- jointMod@stan_args[[1]]$control$max_treedepth
diagnose_sampler %>% 
  ggplot(aes(iteration, treedepth__, color = chain)) + 
  geom_line() + 
  # horizontal line at the value we set our max treedepth
  geom_hline(aes(yintercept = maxtd), color = 'red')
```


```{r}
# param summary
fitsumm <- summary(jointMod)$summary %>% 
  as.data.frame() %>% 
  mutate(variable = rownames(.)) %>% 
  select(variable, everything()) %>% 
  as_tibble()
```

```{r}
#n_eff and Rhat
fitsumm %>% 
  ggplot(aes(n_eff)) + 
  geom_histogram() + 
  geom_vline(aes(xintercept = 3000), color = 'red')
fitsumm %>%
  ggplot(aes(Rhat)) + 
  geom_histogram() + 
  geom_vline(aes(xintercept = 1.1), color = 'red')
```


```{r}
# try to compare a sample of mu to observed
# mu_samp_est <- stansamps %>% slice(nrow(stansamps)-5) %>% unlist()
# mu_samp_obs <- as.matrix(stan_data_joint$sample_data/rowSums(stan_data_joint$sample_data)) %>% c()
# mu_samp_check <- tibble(est=mu_samp_est,ob=c(mu_samp_obs))
# mu_samp_check %>% 
#   ggplot(aes(est,ob))+
#   geom_point()+
#   geom_abline(slope=1,intercept=0,linetype=2)+
#   labs(x="Estimated",y="Observed")
```


```{r}
shinystan::launch_shinystan(jointMod)
```


```{r}
ests <- summary(jointMod,par="log_D")$summary
ests2 <- summary(jointMod,par="log_D_raw")$summary
```


```{r}
# QM_qPCR_joint_out <- QM_qPCR_bayes(m,
#                          stan_data_joint,
#                          NCHAINS=3,
#                          WARMUP = 100,
#                          ITER = 300)
# write_rds(QM_qPCR_joint_out, file = here("model_output/QM_qPCR_MiFish.rds"))
#QM_bayes_out <- readRDS(here("model_output/QM_bayes_MFU.RDS"))
#QM_bayes_out$Bayes_estimates
# QM_bayes_out$Bayes_alpha_est
#summary(QM_bayes_out$Bayes_modelfit)$summary[,"Rhat"] %>% sort() %>% tail()
# rstan::traceplot(QM_bayes_out$Bayes_modelfit, par = "alpha")
```

