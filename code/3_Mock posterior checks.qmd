---
title: "Mock posterior checks"
format: 
  html:
    toc: true
    toc-location: left
    toc-title: "Table of Contents"
    toc-depth: 2
    number-sections: true
    page-layout: full
    self-contained: true 
    collapsible: true
    collapse-level: 1
    # code-summary: "Show/Hide Code"  # Toggle text for code folding
    # css: 'style_gg.css'
    grid:
      sidebar-width: 200px
      body-width: 880px
      margin-width: 200px
      gutter-width: 1.5rem
author: Gled Guri
date: "`r format(Sys.time(), '%d %B, %Y')`"
editor: visual
editor_options: 
  chunk_output_type: console
---

<style>
body {
  font-family: Arial, sans-serif;
  font-size: 18px;
}

h1 {
  font-size: 22px;  /* Adjust the size of H1 headers */
  font-weight: normal;  /* Make H1 headers not bold */
}

h2 {
  font-size: 18px;  /* Adjust the size of H2 headers */
  font-weight: normal;  /* Make H2 headers not bold */
}

h3 {
  font-size: 18px;  /* Adjust the size of H3 headers */
  font-weight: normal;  /* Make H3 headers not bold */
}

h4 {
  font-size: 18px;  /* Adjust the size of H4 headers */
  font-weight: normal;  /* Make H4 headers not bold */
}
</style>

```{r, include=FALSE}
dwidth <- 150
options(width = dwidth)
```

```{r, include=FALSE, warning=FALSE, message=FALSE}
options(width = 300) #wd
```

```{r, include=FALSE, warning=FALSE, message=FALSE}
options(width = dwidth)#wd
```

# Data prep

## Load libraries

```{r, warning=FALSE, message=FALSE}
library(tidyverse)
library(rstan)
library(here)
library(QM);#devtools::install_github("gledguri/QM")
```

# Introduction

We implement and fit a Stan model that jointly models qPCR and metabarcoding data for hake survey samples. The goal is to make quantitative estimates of real eDNA concentration for species for which we have MiFish metabarcoding data, but DO NOT have qPCR data. We use qPCR data from one, common reference species (Pacific hake) to expand metabarcoding read counts into quantitative eDNA concentration estimates.

# Import Data

The first script loads the metabarcoding, qPCR, and mock community data. The second script loads functions that are useful for working with the data and setting up the Stan model.

```{r, results='hide', warning=FALSE, message=FALSE}
# source(here('code','1_load_data.R'))
source(here('code','1_load_data_GG.R'))

source(here("code/qm_data_prep_functions.R"))
```

## Format for Stan

We can prepare the data we just loaded to be input into our Stan model, using some of the functions in the previous script.

```{r, warning=FALSE, message=FALSE}
#qPCR
formatted_qPCR_data <- format_qPCR_data(qPCR_unknowns=qPCR_unk,
                                   qPCR_standards=qPCR_std,
                                   tube_dat = tube_dat,
                                   unk_covariates=c("wash_idx","station_depth_idx"),cov_type = c("continuous","factor"),
                                   unk_offset =c("dilution","volume_offset"))

stan_qPCR_data <- prepare_stan_data_qPCR(formatted_qPCR_data) %>% 
                    # Add Random effect for station
                    c(.,
                      list(X_bio_rep_tube =X_bio_rep_tube,
                           X_bio_rep_obs =X_bio_rep_obs,
                           X_station_depth_tube=X_station_depth_tube,
                           N_bio_rep_RE = N_bio_rep_RE,
                           N_bio_rep_param = N_bio_rep_param,
                           bio_rep_idx =bio_rep_idx,
                           N_bio_rep_idx = N_bio_rep_idx))

# metabarcoding
formatted_metabarcoding_data <- format_metabarcoding_data(input_metabarcoding_data=mfu, 
                                                          input_mock_comm_data=mock,
                                                     Level_1_treatment_envir <- "Sample",
                                                     Level_2_treatment_envir <- "tech",
                                                     Level_3_treatment_envir <- NA,
                                                     # Level_1_treatment_mock <- "Sample",
                                                     # Level_2_treatment_mock <- "Rep",
                                                     # Level_3_treatment_mock <- NA)
                                                     Level_1_treatment_mock <- "Sample",
                                                     Level_2_treatment_mock <- "Mock_type",
                                                     Level_3_treatment_mock <- "Rep")

# linking with qPCR is now done within this function.
stan_metabarcoding_data <-  makeDesign(obs= formatted_metabarcoding_data,
                                       qPCR_tube_obs = formatted_qPCR_data$tube_dat,
                                  # N_pcr_cycles = 43, Nlevels_mock = 2, Nlevels_samp = 2)
                                  N_pcr_cycles = 43, Nlevels_mock = 3, Nlevels_samp = 2)

log_D_link_sp_init_mean = 2
# link_species = "Merluccius productus"
link_species = "Zz_Merluccius productus"
log_D_inits <- makeQM_inits(sample_data =stan_metabarcoding_data$sample_data, 
                         log_D_link_sp_init_mean = log_D_link_sp_init_mean,
                         sp_list = formatted_metabarcoding_data$sp_list,
                         qPCR_ref_sp = link_species )



# get the index of the right species
qpcr_mb_link_sp_idx <- formatted_metabarcoding_data$sp_list$species_idx[formatted_metabarcoding_data$sp_list$species == link_species]

# join the three lists
stan_data_joint <- c(stan_qPCR_data,
                     stan_metabarcoding_data,
                     list(qpcr_mb_link_sp_idx=qpcr_mb_link_sp_idx))
# Check to make sure the order is correct for two of the design matrices that 
# map to observation and the tubes.  Very important.
identical(colnames(X_bio_rep_tube),colnames(X_bio_rep_obs))
identical(colnames(X_station_depth_tube),colnames(stan_data_joint$X_station_depth_obs))

```

Load Gled's mock community data (individual MN runs for each mock) then take the average of alphas produced from each model separately

```{r}
alpha_GG <- read_rds(here('data/mocks/Mock_1_to_4_comparison/Output/','amp_eff_param_all_mocks_all_sp.rds')) %>% 
  filter(!mock_type=='M1_even_2') %>% 
  filter(Species%in%keep) %>% 
  group_by(Species) %>% 
  summarise(mean_alpha=mean(alpha)) %>% 
  arrange(Species) 

#Alpha
alpha_GG

#Load the mean alphas into stan_data_joint
stan_data_joint$alpha_GG <- alpha_GG %>% pull(mean_alpha)
```

Now the data should be ready for Stan. We compile the Stan model itself:

## Load Stan model

```{r}
m <- here('code','qm_qpcr_joint.stan')
m_dm <- here('code','qm_qpcr_joint-DM.stan') # Dirichlet multinomial

m_dm_mock <- here('code','qm_mocks-DM.stan') # Dirichlet multinomial for mocks
m_dm_fix <- here('code','qm_qpcr_joint-DM_alpha-fix.stan')

#IF YOU NEED TO ERROR CHECK, COPY AND PASTE "mc" INTO A NEW SCRIPT TO FIND THE RIGHT LINE NUMBERS
# mc <- cat(stan_model(m)@model_code)
```

# Run

Run Stan

This is the stan code

```{cpp}
#| eval: false

data { 
  
  // DATA FOR qPCR PART OF THE MODEL

  // DATA FOR METABARCODING PART OF THE MODEL
  
  int N_species; // Number of species in data
  int N_obs_mock; // Number of observed mock samples

  // Observed data of mock community matrices
  array[N_obs_mock,N_species] int mock_data;  
  // True proportions for mock community in log ratios
  matrix[N_obs_mock,N_species] alr_mock_true_prop ;
    
  // Design matrices: mock community samples
  vector[N_obs_mock]  model_vector_a_mock;

  // Priors
  array[2] real alpha_prior;// Parameters of normal distribution for prior on alphas
  // real dm_alpha0_mock; // if you want a fixed Dirichlet alpha0 value
  // real tau_prior[2]; // Parameters of gamma distribution for prior on tau (observation precision)
  vector[N_species] alpha_GG; // getting the values from the mean outside of stan
}

transformed data {
}

parameters {
  
  // for QM part
  vector[N_species-1] alpha_raw; // log-efficiencies of PCR in MB
  real log_dm_alpha0_mock; //log-scale alpha param for the Dirichlet multinomial, mocks
}

transformed parameters {

  // for QM part
  vector[N_species] alpha; // vector of efficiency coefficients (log-efficiencies relative to reference taxon)
  // vector[N_obs_mb_samp] eta_samp[N_species]; // overdispersion coefficients
  // vector[N_obs_mock] eta_mock[N_species]; // overdispersion coefficients
  real dm_alpha0_mock; // alpha param for the Dirichlet multinomial, mocks
  matrix[N_obs_mock,N_species] logit_val_mock; //species proportions in metabarcoding, logit
  matrix[N_obs_mock,N_species] prop_mock; // proportion of each taxon in field samples

  // QM MODEL PIECES
  // Fixed effects components
  alpha[1:(N_species-1)] = alpha_prior[1] + alpha_raw * alpha_prior[2];
        // non-centered param beta ~ normal(alpha_prior[1], alpha_prior[2])
  alpha[N_species] = 0; // final species is zero (reference species)

  for (n in 1:N_species) {
    logit_val_mock[,n] = alr_mock_true_prop[,n] + model_vector_a_mock .* alpha[n]; //+eta_mock[n]
  }
  
  dm_alpha0_mock = exp(log_dm_alpha0_mock);
  
  for(m in 1:N_obs_mock){
    prop_mock[m,] = to_row_vector(softmax(to_vector(logit_val_mock[m,]))); // proportion of each taxon in mocks
  }  
 
}

model{
  for(i in 1:(N_species-1)){
    alpha_raw[i] ~ std_normal();
  }
  log_dm_alpha0_mock ~ normal(8,4); // prior on log of Dirichlet multinomial alpha0 for mock communities
  
  // QM Likelihoods
  for(i in 1:N_obs_mock){
    mock_data[i,] ~ dirichlet_multinomial(to_vector(prop_mock[i,])*dm_alpha0_mock); // Multinomial sampling of mu (proportions in mocks)
  }
}

generated quantities {
  array[N_obs_mock, N_species] int mock_data_DM_gnr; 
  array[N_obs_mock, N_species] int mock_data_MN_gnr; 
  array[N_obs_mock, N_species] int mock_data_MN_GG_gnr;
  matrix[N_obs_mock,N_species] logit_val_mock_GG;
  matrix[N_obs_mock,N_species] prop_mock_GG;
  for (n in 1:N_species) {
    logit_val_mock_GG[,n] = alr_mock_true_prop[,n] + model_vector_a_mock .* alpha_GG[n];
  }
  for (i in 1:N_obs_mock) {
    mock_data_DM_gnr[i,] = dirichlet_multinomial_rng(to_vector(prop_mock[i,]) * dm_alpha0_mock, sum(mock_data[i,]));
    mock_data_MN_gnr[i,] = multinomial_rng(to_vector(prop_mock[i,]), sum(mock_data[i,]));
    prop_mock_GG[i,] = to_row_vector(softmax(to_vector(logit_val_mock_GG[i,]))); // proportion of each taxon in mocks
    mock_data_MN_GG_gnr[i,] = multinomial_rng(to_vector(prop_mock_GG[i,]), sum(mock_data[i,]));
  }
}
```

## Dirichlet multinomial

First, run the model for the mock communities

```{r,results='hide'}
# Mocks only
n.chains <- 3
n.warm <- 500
n.samps <- 10000

mocksMod = stan(file = m_dm_mock ,
                data = stan_data_joint,
                verbose = FALSE,
                chains = n.chains,
                thin = 1,
                warmup = n.warm,
                iter = n.warm+n.samps,
                control = list(adapt_init_buffer = 75,
                                  max_treedepth=12,
                                  stepsize=0.01,
                                  adapt_delta=0.8,
                                  metric="diag_e"),
                init = stan_init_f1(n.chains,N_obs_mb = stan_data_joint$N_obs_mb_samp,
                                    N_species = stan_data_joint$N_species,
                                    Nplates=stan_data_joint$Nplates,
                                    N_station_depth=stan_data_joint$N_station_depth
                                    # log_D_link_sp_init_mean=log_D_inits$log_D_link_sp_init_mean,
                                    # log_D_raw_inits=log_D_inits$log_D_raw_inits,
                                    # log_D_inits = log_D_inits$log_D_inits
                                    ),
                #refresh = 100,
                boost_lib = NULL
                # sample_file="tmpU.csv"
                )

#summary(mocksMod)
A <- summary(mocksMod,pars="alpha")
B <- summary(mocksMod,pars="dm_alpha0_mock")

# rstan::traceplot(mocksMod,pars=c("alpha"))
# rstan::traceplot(mocksMod,pars=c("log_dm_alpha0_mock"))

alpha_fix <- A$summary %>% as.data.frame() %>% dplyr::select(mean)
dm_alpha0_mock <- B$summary %>% as.data.frame() %>% dplyr::select(mean)

stan_data_joint <- c(stan_data_joint,
                     list(alpha_fix=(alpha_fix$mean),
                                                dm_alpha0_mock=dm_alpha0_mock$mean))
```

### Posterior predictions of mocks

```{r}
#| fig-width: 14
#| fig-height: 12

#alpha_0
extract(mocksMod,'dm_alpha0_mock') %>% unlist() %>% as.vector() %>% hist(,breaks=100,main='Posterior distribution of alpha_0')

#Mock generated reads through Dirichlet Multinomial
extract_matrix(mocksMod,'mock_data_DM_gnr')

#Mock generated reads through Multinomial
extract_matrix(mocksMod,'mock_data_MN_gnr')

#Mock generated reads through Multinomial alphas estimated individually (non-DM)
extract_matrix(mocksMod,'mock_data_MN_GG_gnr')

#combine mock input with generated reads for mock for the plot
inp_mock <- stan_data_joint$mock_data %>%
  pivot_longer(cols = sp_1:sp_14,
               names_to = 'sp',
               values_to = 'obs_reads')

pred_DM_mock <- extract_matrix(mocksMod,'mock_data_DM_gnr') %>%
  setNames(paste0('sp_',colnames(.))) %>%
  pivot_longer(cols = sp_1:sp_14,
               names_to = 'sp',
               values_to = 'modeled_DM_reads')
pred_MN_mock <- extract_matrix(mocksMod,'mock_data_MN_gnr') %>%
  setNames(paste0('sp_',colnames(.))) %>%
  pivot_longer(cols = sp_1:sp_14,
               names_to = 'sp',
               values_to = 'modeled_MN_reads')
pred_MN_mock_GG <- extract_matrix(mocksMod,'mock_data_MN_GG_gnr') %>%
  setNames(paste0('sp_',colnames(.))) %>%
  pivot_longer(cols = sp_1:sp_14,
               names_to = 'sp',
               values_to = 'modeled_MN_GG_reads')

mock_comp <- 
  cbind(inp_mock,
        pred_DM_mock %>% select(-sp)) %>% 
  cbind(.,
        pred_MN_mock %>% select(-sp)) %>% 
  cbind(.,
        pred_MN_mock_GG %>% select(-sp))


p1 <- mock_comp %>%
  ggplot()+
  geom_point(aes(y=obs_reads,x=modeled_DM_reads))+
  theme_bw()+
  ylab('Observed Mock Reads')+
  scale_y_sqrt(limits = c(0,75000))+
  scale_x_sqrt(limits = c(0,75000))+
  xlab('Predicted (DM) Mock Reads')+
  geom_abline(intercept = 0,slope = 1,lty=2)+
  ggtitle('Observed vs posterior predictives using DM distribution')
p2 <- mock_comp %>%
  ggplot()+
  geom_point(aes(y=obs_reads,x=modeled_MN_reads))+
  theme_bw()+
  scale_y_sqrt(limits = c(0,75000))+
  scale_x_sqrt(limits = c(0,75000))+
  ylab('Observed Mock Reads')+
  xlab('Predicted (MN) Mock Reads')+
  geom_abline(intercept = 0,slope = 1,lty=2)+
  ggtitle('Observed vs posterior predictives using MN distribution')
p3 <- mock_comp %>%
  ggplot()+
  geom_point(aes(y=obs_reads,x=modeled_MN_GG_reads))+
  theme_bw()+
  scale_y_sqrt(limits = c(0,75000))+
  scale_x_sqrt(limits = c(0,75000))+
  ylab('Observed Mock Reads')+
  xlab('Predicted (MN) Mock Reads (each mock samp separate)')+
  geom_abline(intercept = 0,slope = 1,lty=2)+
  ggtitle('Observed vs posterior predictives using separate MN distribution for each mock')
p4 <- mock_comp %>%
  ggplot()+
  geom_point(aes(y=modeled_DM_reads,x=modeled_MN_GG_reads))+
  theme_bw()+
  scale_y_sqrt(limits = c(0,75000))+
  scale_x_sqrt(limits = c(0,75000))+
  ylab('Predicted (DM) Mock Reads')+
  xlab('Predicted (MN) Mock Reads (each mock samp separate)')+
  geom_abline(intercept = 0,slope = 1,lty=2)+
  ggtitle('Posterior predictives using MN distribution vs posterior predictives using separate MN distribution for each mock')
cowplot::plot_grid(p1,p2,p3,p4,nrow = 2)
```
